jmp main:

; ----- API FUNCTIONS -----
print: db "print\0"
fopen: db "fopen\0"
ftell: db "ftell\0"
fgetc: db "fgetc\0"
fseek: db "fseek\0"
fread: db "fread\0"

; ----- GLOBALS -----
SIZEOF_TOKEN:			di 24
SIZEOF_TOKEN_LIST:		di 16
SIZEOF_LEX_STATE:		di 24
SEEK_SET:				di 1
SEEK_END:				di 2
SEEK_CUR:				di 3 
FORMAT_NUM:				db "NUM: %d\n\0"
FORMAT_CHAR:			db "CHAR: %c\n\0"
FORMAT_STR:				db "STR: %s\n\0"

; ----- FUNCTIONS USED EVERYWHERE -----

; ARGS
;	0: bytes: int
; RETURN
;	0: ptr: byte^ 
safe_malloc:
	; stack map
	; 0: bytes: int
	; 1: malloc_result: byte^	
	iarg	0
	res		1 
	
	; [1] = malloc([0]);	
	ilocall	0
	malloc
	ilocals 1		
	
	; jump to survived if not zero
	ilocall 1
	itest
	jnz		.survived

	; reached if zero... error 
	iconst	.dietext
	cfcall	print, 1
	exit
.survived:
	ilocall	1
	iret
.dietext: db "MINICOMPILER: OUT OF MEMORY\n\0"



; ----- START LEXER -----
; struct Token {
;	[0]: int type; (0 = NOTYPE, 1 = INTEGER, 2 = FLOAT, 3 = IDENTIFIER, 4 = OPERATOR)
;	[8]: int line;
;	[16]: union {
;		int ival;
;		float fval;
;		byte^ sval;
;		byte oval;
;	};
; };
; sizeof(Token) = 24

; struct TokenList {
;	[0]: Token^ token;
;	[8]: TokenList^ next;
; };
; sizeof(TokenList) = 16

; struct LexState {
;	[0]: byte^ contents;
;	[8]: int line;
;	[16]: TokenList^ tokens;
; };
; sizeof(LexState) = 24

; NOARGS
; RETURN: allocated Token^
new_token:
	aider	SIZEOF_TOKEN
	call	safe_malloc, 1
	iret

; NOARGS
; RETURN: allocated TokenList^
new_token_list:
	aider	SIZEOF_TOKEN_LIST
	call	safe_malloc, 1
	iret

; ARGS
;	0: byte^ contents (!! not copied !!)
; RETURN allocated LexState^
new_lex_state:
	; stack map
	; 0: contents
	; 1: LexState^
	iarg	0
	res		1

	; [1] = malloc(SIZEOF_LEX_STATE);
	aider	SIZEOF_LEX_STATE
	call	safe_malloc, 1
	ilocals	1

	; [1]->contents = [0]
	ilocall	1
	ilocall	0
	isave
	
	; [1]->line = 0
	ilocall	1
	iinc	8
	iconst	0
	isave	

	; [1]->tokens = malloc(SIZE_TOKEN_LIST)
	ilocall	1
	iinc	16
	aider	SIZEOF_TOKEN_LIST
	call	safe_malloc, 1
	isave

	; [1]->tokens->token = NULL
	ilocall	1
	iinc	16
	ider
	iconst	0
	isave

	; [1]->token->next = NULL
	ilocall	1
	iinc	16
	ider
	iinc	8
	iconst	0
	isave

	ilocall	1
	iret
		

; ARGS
;	0: char: byte
; RETURN (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z')
isalpha:
	; stack map
	; 0: char to check
	barg	0
	blocall	0
	iconst	'a'
	icmp
	jlt		.elseif
	; if reached here, it's >= 'a'... check <= 'z'
	blocall	0
	iconst	'z'
	icmp
	jgt		.elseif
	; if reached here, it's >= a <= z... return true
	jmp		.rettrue
.elseif:
	; if reached here, test for >= 'A' && <= 'Z'
	blocall	0
	iconst	'A'
	icmp
	jlt		.retfalse
	blocall	0
	iconst	'Z'
	icmp
	jgt		.retfalse
	jmp		.rettrue
.retfalse:
	iconst	0
	jmp		.done
.rettrue:
	iconst	1
	jmp		.done
.done:
	iret

; ARGS
;	0: char: byte
; return (char >= '0' && char <= '9')
isdigit:
	; stack map
	; 0: char to check
	barg	0
	blocall	0
	iconst	'0'
	icmp	
	jlt		.retfalse
	; now check <= '9'
	blocall	0
	iconst	'9'
	icmp
	jgt		.retfalse
	jmp		.rettrue
.retfalse:
	iconst	0
	jmp		.done
.rettrue:
	iconst	1
	jmp		.done
.done:
	iret

; ARGS
;	0: parse state
; RETURNS: current character pointer to by PS->contents
onchar:
	; stack map
	; 0: parse state
	iarg	0

	ilocall	0
	ider ; get contents
	bder ; get character pointer to

	iret

; ARGS
;	0: parse state
;	1: amount
; NO RETURN
next:
	; stack map
	; 0: parse state
	; 1: amount
	iarg	0
	iarg	1

	; contents = contents + amount
	ilocall	0
	ilocall	0
	ider
	ilocall	1
	iadd
	isave

	vret

; ARGS
;	0: parse state
; RETURN: 1 or 0
matches_int:
	; stack map
	; 0: parse state
	iconst	0
	iret

matches_float:
	iconst	0
	iret

matches_string:
	iconst	0
	iret

matches_identifier:
	iconst	0
	iret

matches_operator:
	iconst	0
	iret

lex_int:
	vret

lex_float:
	vret

lex_string:
	vret

lex_identifier:
	vret

lex_operator:
	vret

; ARGS
;	0: filename: byte^
lex_main:
	; stack map
	; 0: filename: byte^
	; 1: handle: FILE*
	; 2: contents: byte^
	; 3: lex state
	; 50+: general purpose
	iarg	0
	res		100
	
	; fopen([0], "rb");	
	iconst	.rb	
	ilocall	0
	cfcall	fopen, 2
	ilocals	1
	
	; abort and print error message if file can't be opened
	ilocall	1
	itest
	jnz		.fsafe
	; !! failed !!
	ilocall	0
	iconst	.ffail
	cfcall	print, 2
	pop
	exit
.fsafe:
	
	; get length of file
	; fseek([1], SEEK_END, 0);
	iconst	0
	aider	SEEK_END
	ilocall	1
	cfcall	fseek, 3
	pop

	; [50] = ftell([1]);
	ilocall	1
	cfcall	ftell, 1
	ilocals	50
	
	; fseek([1], SEEK_SET, 0);
	iconst	0
	aider	SEEK_SET
	ilocall	1
	cfcall	fseek, 3
	pop

	; [2] = malloc([50] + 1);
	ilocall	50
	iinc	1
	call	safe_malloc, 2
	ilocals	2

	; fread([1], [2], [50]);
	ilocall	50
	ilocall	2
	ilocall	1
	cfcall	fread, 3
	pop

	; *([2] + [50]) = 0
	ilocall	2
	ilocall	50
	iadd
	iconst	0
	isave

	; create lex state
	ilocall 2
	call	new_lex_state, 1
	ilocals	3

.looptop:
	; while (onchar(PS) != 0)
	ilocall	3
	call	onchar, 1
	itest
	jz		.loopbot
	
	; [50] = onchar(PS)
	ilocall	3
	call	onchar, 1
	ilocals	50
	
	; if matches/lex statements	
.int:
	ilocall	3
	call	matches_int, 1
	itest
	jz		.float
	ilocall	3
	call	lex_int, 1
	jmp		.doneswitch
.float:
	ilocall	3
	call	matches_float, 1
	itest
	jz		.identifier
	ilocall	3
	call	lex_float, 1
	jmp		.doneswitch
.identifier:
	ilocall	3
	call	matches_identifier, 1
	iotest
	jz		.unknowntok
	ilocall	3
	call	lex_identifier, 1
	jmp		.doneswitch
.unknowntok:
	
.doneswitch:

	; next(PS, 1)
	iconst	1
	ilocall	3
	call	next, 2

	jmp		.looptop
.loopbot:

	vret
.rb: db "rb\0"
.char: db "READ CHARACTER: %c\n\0"
.ffail: db "COULDN'T OPEN '%s'. ABORT\n\0"
.contents: db "CONTENTS: %s\n\0"
	

; ----- ENTRY POINT -----
main:
	; lex_main(filename)
	iconst	.filename
	call	lex_main, 1

	exit

.filename: db "demo/sample_file.spy\0"
	
