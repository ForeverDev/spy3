jmp main:

; ----- API FUNCTIONS -----
print: db "print\0"
fopen: db "fopen\0"
ftell: db "ftell\0"
fgetc: db "fgetc\0"
fseek: db "fseek\0"
fread: db "fread\0"

; ----- GLOBALS -----
SIZEOF_TOKEN:			di 24
SIZEOF_TOKEN_LIST:		di 16
SEEK_SET:				di 1
SEEK_END:				di 2
SEEK_CUR:				di 3 
FORMAT_NUM:				db "NUM: %d\n\0"

; ----- FUNCTIONS USED EVERYWHERE -----

; ARGS
;	0: bytes: int
; RETURN
;	0: ptr: byte^ 
safe_malloc:
	; stack map
	; 0: bytes: int
	; 1: malloc_result: byte^	
	iarg	0
	res		1 
	
	; [1] = malloc([0]);	
	ilocall	0
	malloc
	ilocals 1		
	
	; jump to survived if not zero
	ilocall 1
	itest
	jnz		.survived

	; reached if zero... error 
	iconst	.dietext
	cfcall	print, 1
	exit
.survived:
	ilocall	1
	iret
.dietext: db "MINICOMPILER: OUT OF MEMORY\n\0"



; ----- START LEXER -----
; struct Token {
;	int type; (0 = NOTYPE, 1 = INTEGER, 2 = FLOAT, 3 = IDENTIFIER, 4 = OPERATOR)
;	int line;
;	union {
;		int ival;
;		float fval;
;		byte^ sval;
;		byte oval;
;	};
; };
; sizeof(token) = 24

; NOARGS
new_token:
	aider	SIZEOF_TOKEN
	call	safe_malloc, 1
	iret

; NOARGS
new_token_list:
	aider	SIZEOF_TOKEN_LIST
	call	safe_malloc, 1
	iret

; ARGS
;	0: filename: byte^
lex_main:
	; stack map
	; 0: filename: byte^
	; 1: handle: FILE*
	; 2: contents: byte^
	; 50+: general purpose
	iarg	0
	res		100
	
	; fopen([0], "rb");	
	iconst	.rb	
	ilocall	0
	cfcall	fopen, 2
	ilocals	1
	
	; abort and print error message if file can't be opened
	ilocall	1
	itest
	jnz		.fsafe
	; !! failed !!
	ilocall	0
	iconst	.ffail
	cfcall	print, 2
	pop
	exit
.fsafe:
	
	; get length of file
	; fseek([1], SEEK_END, 0);
	iconst	0
	aider	SEEK_END
	ilocall	1
	cfcall	fseek, 3
	pop

	; [50] = ftell([1]);
	ilocall	1
	cfcall	ftell, 1
	ilocals	50
	
	; fseek([1], SEEK_SET, 0);
	iconst	0
	aider	SEEK_SET
	ilocall	1
	cfcall	fseek, 3
	pop

	; [2] = malloc([50] + 1);
	ilocall	50
	iinc	1
	call	safe_malloc, 2
	ilocals	2

	; fread([1], [2], [50]);
	ilocall	50
	ilocall	2
	ilocall	1
	cfcall	fread, 3
	pop

	; *([2] + [50]) = 0
	ilocall	2
	ilocall	50
	iadd
	iconst	0
	isave
	
	; the contents of the file are now loaded into [2]...
	; now, lex the file

	; [3] will be used to scan the contents, [2] will remain
	; the contents pointer
	ilocall	2
	ilocals	3

.looptop:
	; while (*[3] != 0)
	ilocall	3
	bder
	itest	
	jz		.loopbot
	
	; increment pointer, store back in [3], loop	
	ilocall	3
	iinc	1
	ilocals	3
	jmp		.looptop
.loopbot:

	vret
.rb: db "rb\0"
.char: db "READ CHARACTER: %c\n\0"
.ffail: db "COULDN'T OPEN '%s'. ABORT\n\0"
.contents: db "CONTENTS: %s\n\0"
	

; ----- ENTRY POINT -----
main:
	; lex_main(filename)
	iconst	.filename
	call	lex_main, 1

	exit

.filename: db "demo/sample_file.spy\0"
	
